# Introduction #

Документ описывает принятый в GameBoost стиль написания кода, именования переменных, классов, констант и т.д. Всем разработчикам настоятельно рекомендуется придерживаться этих соглашений.


# Details #

# Заголовки #

## #define Guard ##

Используется директива
```
#pragma once
```

## Зависимые заголовки ##

По возможности следует избегать включать заголовки других файлов в Ваших заголовках. Если это всё же необходимо, их следует размещать перед namespace gb.
```
#pragma once
#include "io/file.h"

namespace gb
{
```

## Имена и порядок включения .h файлов ##

Имена файлов пишутся строчными (маленькими) буквами с подчёркиваниями между словами.

Имя файла заголовка пишется в двойных кавычках, полный путь от корневой папки проекта, поскольку ожидается, что корневая папка проекта будет добавлена в список папок для включения C++ компилятора.

## Inline функции ##
## Порядок параметров функций ##

# Именование #

## Namespace ##

Всё, что принадлежит библиотеке GameBoost, следует заключить в:
```
namespace gb
{
}
```

Вложенные подпапки должны отвечать вложенному namespace:
К примеру gb/io/io.h будет находиться в:
```
namespace gb
{
    namespace io {
    } // namespace gb
} // namespace io
```

Позволяется использовать более одного уровня вложенности пространств имён для личных потребностей разработчиков (сокрытия деталей реализации и т.д.). В главный API такие глубоко вложенные пространства имён попадать не должны.

Использование using namespace и namespace X = Y; в заголовках .H, .INL - ЗАПРЕЩЕНО, с целью борьбы с засорением глобального пространства имён. Однако разрешается использовать эти директивы в файлах .CPP.

## Статические, глобальные и дружественные функции ##
## Локальные переменные ##
## Статические и глобальные переменные ##

# Классы #

## Действия в конструкторах ##
## Конструкторы по умолчанию ##
## Явные конструкторы ##
## Конструкторы копирования ##
## Структуры против Классов ##
## Наследование ##
## Множественное наследование ##
## Интерфейсы ##
## Перегрузка операторов ##
## Права доступа к членам класса ##
## Порядок объявления ##
## Короткие функции ##

# Прочие С++ особенности #

## Аргументы по ссылке ##
## Перегрузка функций ##
## Аргументы по умолчанию ##

Следует избегать аргументов по умолчанию, поскольку они затрудняют понимание способа передачи параметров в функцию. Однако это не запрещается.

## Исключения ##
## Run-Time Type Information (RTTI) ##

## Приведение типов ##

Следует избегать пользоваться преобразованием типов, принятым в стандартном C. Приемлемым является приведение числовых типов и доступ к перегруженным приведениям типов в классах:
```
float f = 0.0f;
int32_t a = (int32_t)f;

vec3 v( 1, 2, 3 );
float length = (float)v;
```
Для прочих нужд использовать приведение типов, принятое в C++: reinterpret\_cast, static\_cast, dynamic\_cast.

Для приведения строк к числам и наоборот, поощряется использование boost::lexical\_cast.

## Потоки ##
## Preincrement и Predecrement ##
## Использование const ##
## Целочисленные типы ##

Использовать строго стандартизованные числовые типы, находящиеся в stdint.h или inttypes.h:
```
bool
int8_t
uint8_t
int16_t
uint16_t
int32_t
uint32_t
int64_t
uint64_t
```
TODO: Создать заголовок библиотеки GameBoost для определения этих типов данных централизованно.

## 64-bit совместимость ##
## Little/Big Endian совместимость ##
## Макросы препроцессора ##
## 0 и NULL ##
## sizeof ##
## Boost ##
## C++0x ##

# Именование #

## Общие правила именования ##
## Имена классов ##

Классы именуются коротко и с БольшойБуквы. Префикс C`*` не используется, но автор по своему усмотрению может дописать typedef для синонима класса с префиксом C`*`.

## Имена файлов ##

Файлы называются маленькими латинскими буквами с подчёркиваниями.
Файлы кода имеют расширение .CPP, файлы заголовков - расширение .H, файлы с инлайн кодом, которые инклюдятся, но не должны компилироваться системой автосборки - расширение .INL

## Имена типов данных ##

Простые числовые и шаблонные типы предлагается называть маленькими буквами, с подчёркиваниями между словами и суффиксом `_`t:
```
typedef std::list <int32_t> int_list_t;
```

Структурам - либо давать личные имена, как классам, либо использовать суффикс `_`s.

## Имена переменных ##

Локальные переменные именуются маленькими буквами с подчёркиванием между словами. Желательно использовать имена существительные.

## Имена констант ##

Константы, как и директивы препроцессора, пишутся заглавными буквами, с подчёркиваниями между словами.
```
static const int32_t NUM_RETRIES = 100;
```

## Имена функций ##

Функции именуются маленькими буквами с подчёркиванием между словами. Желательно использовать глаголы инфинитивы или императивы (сделать=do`_*`, открыть=open`_*`, нарисовать=draw`_*`).

Проверочные функции, возвращающие bool именуются в вопросительной форме is`_*` или has`_*`

## Имена пространств имён ##

Главное пространство имён - gb (GameBoost), вложенное пространство имён первого уровня должно отображать модуль, в котором находится данный код.

Более глубокие уровни вложенности позволяются, но остаются на совести программиста, и не должны попадать в главный API. Хорошим применением для таких пространств имён является сокрытие деталей реализации от пользователя.

## Имена перечислений ##

Аналогично константам имена значений пишутся заглавными буквами с подчёркиваниями между словами. Перечисления должны быть завёрнуты в структуру для выноса их из общего пространства имён
```
struct my_enum_t {
  typedef enum {
    VALUE1,
    VALUE2,
  } type;
};
// использовать как:
my_enum_t::type x = my_enum_t::VALUE1;
```

## Имена макросов ##

Макросы именуются строго большими буквами с подчёркиваниями между словами. Имена макросов имеют префикс GB`_*`

Если макрос не нужен за пределами своего файла, надо его удалить командой #undef.

## Исключения из правил ##

# Комментарии к коду #

## Стиль комментариев ##

Комментарии должны соответствовать стандарту Doxygen.

Приветствуются краткие комментарии типа:
```
//! Стартуем событие
void start_event();

//! Стартуем событие
//! \param int x - номер события
void start_event( int x );
```

## Заголовки файлов ##
## Комментарии к классам ##
## Комментарии к функциям ##
## Комментарии к переменным ##
## Комментарии к коду ##
## Пунктуация ##
## Правописание ##

# Форматирование кода #

## Длина строк ##

Разумный предел - 80-100 символов в строке. Более длинные строки позволяются, но очень неудобны для многих разработчиков. Старайтесь так перенести строку, чтобы она легко читалась и выглядела одним целым с началом строки.

## Не-ASCII символы ##

Все файлы должны храниться в кодировке UTF8 без маркера BOM - это важно для компиляторов gcc4.3 и более младших версий.

Скрипт для удаления маркеров BOM из дерева исходников:
```
#!/usr/bin/python
# coding: utf-8
# Вырезать из всех *.cpp, *.h файлов проекта отметки Unicode-BOM
import fnmatch
import os

def cut_bom( fpath ):
    f = file( fpath, "rb" )
    head_bytes = f.read( 3 )
    if head_bytes == "\xEF\xBB\xBF":
        rest = f.read()
        f.close()
        f = file( fpath, "wb" )
        f.write( rest )
        print "cut file " + fpath

    f.close()

def walk_helper ( rootPath, pattern ): 
    for root, dirs, files in os.walk( rootPath ):
        for filename in fnmatch.filter( files, pattern ):
            p = os.path.join( root, filename )
            cut_bom( p )

def walk( rootPath ):
    walk_helper ( rootPath, "*.cpp" )
    walk_helper ( rootPath, "*.h" )
 
walk( 'ИМЯПАПКИ' )
```

## Пробелы или табуляции? ##

Используются символы табуляций. Размер табуляции выбирается по личному предпочтению каждого программиста.

## Объявления и тела функций ##
## Вызовы функций ##
Пробелы внутри скобок.
```
do_something( x, 1 );
```
## Условные операторы ##
Пробелы внутри скобок.
```
if ( x == 0 )
{
}
// более короткие
if ( x == 0 ) {
    1-2 строки кода
}
// однострочные
if ( x == 0 ) return;
```
## Циклы и switch() ##
Пробелы внутри скобок и после точек с запятыми:
```
for ( x = 0; x < 10; ++x )
{
}
```
## Указатели и ссылки ##
```
char * x;
myclass & y;
```
## Логические выражения ##
## Возвращаемые значения ##
## Инициализация переменных и массивов ##
## Директивы препроцессора ##
## Формат классов ##
### Конструкторы ###
### Списки инициализации членов класса ###
## Форматирование пространств имён ##
## Исключения из правил ##